package com.human.factory.simple;

/**
 * <>消费者</>
 *
 * @author human
 * @version V1.0
 * @Time 2020/4/25
 */
public class Consumer {
    /**
     * 首先，工厂是用来生产产品的，比如 这个产品就是一辆车，那此时工厂就是用来造汽车的工厂。
     * 用户想买一辆车，找到工厂（此处跨过4s店啥的哈，别想的那么复杂），告诉工厂具体的品牌、型号……,工厂造好车，返回给用户
     * <p>
     * 简单工厂模式的思想：
     * 那么，简单工厂，就是不论什么车，这个工厂都能造，比如，我想要量宝马，好，工厂造好返给你；我想要量奔驰，可以，工厂造好给你 ……
     * 工厂要处理用户的需求，
     *
     * 例如: 看代码实现
     *  ① 有钱了，哥们要买宝马车，找到工厂，告诉getCar()，我要宝马，传个名字，此时工厂就去造车了，但是具体造车的逻辑，客户是不知道的，这个逻辑都在汽车工厂内部解决，造好给客户……，客户开宝马去泡妞了……
     *  ② 又来个客户，问getCar() 小姐姐，有没有奔驰，给我整一辆，……………………，工厂又去造车了，哥们交钱开走了
     *
     *  那么，经过以上的代码逻辑，会发现，简单工厂这种方式，在去造车之前，要先搞一个实现类（比如：Baoma,Benze ）实现一个公共的Car接口，
     *  那也就意味着，每造一种车，就会创建个实现类，然后改一下CarFactory这个工厂的逻辑，是不是耦合性太高了。如③
     *  这样也违背了开闭原则（即关闭修改，开放新增）
     */

    public static void main(String[] args) {
        //①买一辆宝马
        Car baoCar = CarFactory.getCar("宝马");
        //②想买一辆奔驰
        Car benCar = CarFactory.getCar("奔驰");

        //③ 又来一个客户，我要买捷达，工厂又去创建个 Jieda类实现Car, 然后修改CarFactory 增加逻辑， 周而复始……

        baoCar.name();
        benCar.name();

    }
}
