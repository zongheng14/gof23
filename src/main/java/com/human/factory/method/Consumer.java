package com.human.factory.method;

/**
 * <>消费者</>
 *
 * @author human
 * @version V1.0
 * @Time 2020/4/25
 */
public class Consumer {
    /**
     * 经过简单工厂模式的洗礼，发现每次客户都要直接跟工厂去对接，且每次买厂子里没有的车，工厂都得在原有的类中增加逻辑，耦合度太高了
     * 所以，有了工厂方法模式
     * 思想：
     * 就是以前由一个总工厂(CarFactory)来生产所有的车，但是现在呢，总工厂提供标准（也就是作为接口，提供公共的方法），需要创建各个分工厂来实现总工厂标准，造属于自己的车
     * <p>
     * 看代码实现：
     * ① 客户买宝马，去了造宝马的工厂（BaomaFactory），宝马工厂造完，给客户
     * ② 客户买奔驰，去了造奔驰的工厂（BenzeFactory），奔驰工厂造完，给客户
     * ……
     * 这样，每个客户直接找对应的造车工厂，每个造车工厂单独实现总工厂的标准，即使是 新来客户买目前没有的车（如③），我们只需要增加这种对应的车辆工厂去实现总工厂的标准即可，不用修改任何原来程序的逻辑。
     * <p>
     * 缺点： 虽然不影响原来的逻辑，但是也是需要造大量的工厂类和对应工厂的实现类。工厂类会及其庞大
     */

    public static void main(String[] args) {
        //①买一辆宝马
        Car baoCar = new BaomaFactory().getCar();
        //②想买一辆奔驰
        Car benCar = new BenzeFactory().getCar();

        //③ 又来一个客户，我要买捷达，再建个捷达工厂，实现总工厂标准，这样可以在不改变原有的程序，只增加需要的工厂和实现类即可

        baoCar.name();
        benCar.name();

    }
}
